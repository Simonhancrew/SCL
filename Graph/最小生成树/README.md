## MST(Minimum Spanning Tree)

定义比较简单，就是针对无向连通图的边权和最小的树

有几个基础的理论:

1. 任意一个最小生成树一定可以包含无向图中权值最小的边

2. 森林

主要有两个算法

### Prim

prim是一种极其好写的最小生成树算法。和dij的思路极其的类似，也有朴素版和堆优化版。

该算法的基本原理就是从一个点开始，不断的加点。每次找到不在集合中的距离集合的最近的点

然后把他加入集合，更新生成权值，此时如果他离集合的距离是无穷大的话就代表树不连通

最后更新其周围的点到集合的距离。

复杂度O(n * n)

```cpp
int prim(){
    // 集合st中是已经建好的树
    // 1 初始化距离都为无穷大
    memset(d,0x3f,sizeof d);
    d[1] = 0;
    int res = 0;
    // 2 更新n次
    for(int i = 0;i < n;i++){
        int t = -1;
        // 找到不在集合中距离集合最小的节点
        for(int j = 1;j <= n;j++){
            if(!st[j] && (t == -1 || d[t] > d[j])){
                t = j;
            }
        } 
        // 3 第一次不更新距离，如果某次t到集合的距离是INF则无法联通
        // 最近都是无穷大，必不可能联通
        if(d[t] == INF) return INF;
        // 4 更新距离，更新剩下节点到集合的距离。//考虑负环的情况，需要先更新距离再去更新d 
        res += d[t]; 
        for(int j = 1;j <= n;j++) d[j] = min(d[j],g[t][j]);
        // 5 将这个节点加入生成集合
        st[t] = true;
    }
    return res;
}
```

### Kruskal

从小到大加入边，针对每条边的两个节点，看看是否在一个集合之中。

如果在的话不做操作，否则将两个集合合并。

因为保证了边权的从小到大排列，遍历到某条边x(u->v)的时候，当u->v这条边不连通的时候，

当前边一定是合并的最小花费（因为前面不连通，假设后续不经过u->v这条边形成了最终的树，则可以证明，
此时的边权和一定是大于u->v这条边的）.

确定有最小生成树下，，一定至少需要经过n - 1条边。

否则生成一个最小生成森林

```cpp
int kruskal(){
    //按照权重从小到大排序所有的边
    sort(edge,edge + m);
    //初始并查集
    for(int i = 1;i <= n;i++) p[i] = i;
    //res是生成树最后的权重，cnt是经过的边数
    int res = 0,cnt = 0;
    for(int i = 0;i < m;i++){
        int a = edge[i].a,b = edge[i].b,w = edge[i].w;
        a = find(a),b = find(b);
        if(a != b){
            //加入集合
            p[a] = b;
            res += w;
            cnt ++;
        }
    }
    //应该会经过至少n-1条边
    if(cnt < n - 1) return INF;
    return res;
}
```