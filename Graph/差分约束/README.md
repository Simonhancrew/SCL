## 差分约束

一种特殊的n元一次方程组，包含n个变量和m个约束条件，每个约束条件是由两个其中的变量做差表示的。

我们要解决的问题是求一组解，使得所有的约束条件得到满足。否则就可以判定无解。

差分约束中的每个条件 $ x_i - x_j \le c_k $ 都可以变形成 $ x_i \le x_j + c_k $,这和单元最短路中的$dist[y] \le dist[x] + w$非常的类似。因此可以把每个变量看作图中的节点，每个约束条件看作节点j向i连接的一条长度$c_k$的边。

一个值得注意的问题，$\{a_1,a_2,a_3,...,a_n\}$如果是差分约束系统的一组解，那么对于任意的常熟d，$ \{a_1 + d,a_2 + d,a_3 + d,...,a_n + d\} $显然也是一组解（d可以被消掉）

其中存在一个重要的先决条件，从源点出发一定可以走到所有的边（所以常建一个虚拟源点）

设dist[0] = 0,并且向每一个点连接一条权重为0的边，做一次单源最短路，如果整体存在负环，则证明给定的差分系统无解。否则$x_i = dist[i]$为该差分约束系统的一组解。

如果使用SPFA的话，最坏情况下的复杂度是O(nm)的

### 实现过程

1. 把每个x[i] ≤ x[j] + C[k]不等式转化为一条从x[j]走到x[i]长度为C[k]的边

2. 然后在这个图上找一个超级源点,使得该源点一定可以遍历到所有边 

3. 从源点求一遍 单源最短路
    
    3.1. 假如存在负环
    ```
        x[1]→x[2]→x[3]→x[k]
            ↑ c1   c2   c3 ↓
            ← ← ← ← ← ← 
                ck
        x[2]≤ x[1]+c[1]
            ...
        x[k]≤ x[k-1]+c[k-1]
        x[1]≤ x[k]+c[k]
    ```

    对第一个不等式用后面的不等式一直做松弛
    ```
        x[2] ≤ x[1]+c[1]
            ≤ x[k]+c[k]+c[1]
            ≤ x[k-1]+c[k-1]+c[k]+c[1]
            ...
            ≤ x[2]+c[2]+...+c[k-1]+c[k]+c[1]
            ≤ x[2]+(小于零的Σc[i])
        x[2] < x[2]
    ```
    即矛盾,得出结论:不等式无解 <=> 存在负环
4. 求完单源最短路之后
    
    4.1.  存在负环 => 不等式无解
    
    4.2.  没有负环 => 求完之后一定是满足这个不等式的 <=> 即一个可行解

### 类比最短路or最长路

注意差分约束的关系对应的是最(长)路求完之后的dist对应关系

1. 最短路
```
    i→j   求之前 d[j] > d[i]+c 
    c    求完后 d[j] ≤ d[i]+c 
    即if(d[j] > d[i] + w) {
        d[j] = d[i] + w
    }
    需要满足关系：
    d[j] <= d[i] + w;建立一条i->j的边
```
一个图里每个点求完最短距离后每个点的最短距离都有第二个不等式满足

即任何一个最短路问题 可以 转化为一个差分约束问题

同理  一个差分约束问题 可以 转化为一个单源最短路问题

2. 最长路
```
    i→j   求之前 d[j] < d[i]+c 
    c     求完后 d[j] ≥ d[i]+c  
    可以理解成
    if(d[j]<d[i]+w[i][j])
        d[j] = d[i] + w[i][j]
    即初始关系x[j] >= x[i] + w
    建立一条i->j的边
```

### 求解最大值和最小值

结论：如果求解的是最大值，应该求解一个最短路。如果求解的是最小值，应该求解一个最短路。

问题1:如何转化x[i] ≤ c 其中c是一个常数 这类的不等式

方法:建立一个超级源点,0号点x[0],然后建立0→i 长度是c的边即可

```
    x[i] ≤ c
        <=>
    x[i] ≤ x[0] + c = 0 + c   
```

以求x[i]的最大值为例:所有从x[i]出发,构成的不等式链   

```
x[i] ≤ x[j] + c[j] 
≤ x[k] + c[k] + c[j]
≤ x[0] + c[1]+ c[2]+... + c[j] 
=   0  + c[1]+ ... + c[j] 
```

所计算出的上界,最终x[i]的最大值=所有上界的最小值

```
举例 x[i] ≤ 5
         x[i] ≤ 2
         x[i] ≤ 3
         max(x[i]) = min(5,2,3) = 2
    0 → 1 → 3 → 5 → ... → i
      c1  c3  c5       ci-1
    x[1] ≤ x[0] + c[1] 
    x[3] ≤ x[1] + c[3] 
    x[5] ≤ x[3] + c[5]
    ...
    x[i] ≤ x[i-1] + c[i-1]
    则
    x[i] ≤ x[i-1] + c[i] 
         ≤ x[i-3] + c[i-3] + c[i]
         ...
         ≤ x[0] + c[1] + c[3] + c[i-3] + c[i-1]

可以发现Σc[i]就是从0→i的一条路径的长度
```

```
那么
    求x[i]最大值
        <=>
    求所有上界的最小值
        <=>
    求所有从0→i的路径和的最小值
        <=>
    最短路求dist[i]

同理 求x[i]最小值
        <=>
    求所有下界的最大值
        <=>
    求所有从0→i的路径和的最大值
        <=>
    最长路求dist[i]
```
    