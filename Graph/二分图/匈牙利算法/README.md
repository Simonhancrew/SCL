## 匈牙利算法

主要用来解决求二分图的最大匹配数和最小点覆盖问题。前提是图要构成一个二分图

### 最大匹配问题

在二分图中最多能找到多少条没有公共端点的边，最大匹配等价于不存在增广路径。

实现流程(假设图非为两部分，左图和右图)：
    1. 针对左图的每个点，找右侧的连接点，右图的点，在当前匹配中只能找一次。
    2. 如果当前右图的点没有在之前的匹配中被连接过，或者右图的点在左侧的点能够找到新的配对关系，则这对关系依然是成立的

```cpp
bool find(int x){
    for(int i = h[x];i != -1;i = ne[i]){
        int j = e[i];
        if(!st[j]){
            st[j] = true;
            if(match[j] == 0 || find(match[j])){
                match[j] = x;
                return true;
            }
        }
    }
    return false;
}

for(int i = 1;i <= n1;i++){
        //每次开始都是全部没找过的
        //match中是记录着右到左的信息
        memset(st,false,sizeof st);
        if(find(i)) res++;
    }
```

### 最小点覆盖问题

最大匹配数 = 最小点覆盖 = 总点数 - 最大独立集 = 总点数 - 最小路径覆盖

最小点覆盖是针对图来说的，从图中选出最少的点，满足每条边至少一个端点被选。

不难发现补集是独立集

### 最大独立集

选最多的点，满足两两之间没有边相连.

等价于去掉最少的点将所有的边都破坏掉(m个点)

等价于找最小点覆盖(m个点)

等价于找最大匹配（m个点）

结果就是n - m

### 最小路径点覆盖

最小路径覆盖 = 总点数 - 最大匹配数

DAG(有向无环图），用最少的互不相交的路径 将所有点覆盖

拆点成两部分，原图有边i→j

则有 i→j'
    出点 入点

原图变为从左边(出点)连向右边(入点)的二分图。则最少互不相交的路径=n-m(最大点覆盖数量)

原图中的每条路径 转化到新图，每个点最多只有一个出度一个入度 

<=> 新图中的任意两条边之间不相交

<=> 新图中的边都是匹配边

每个路径终点 对应一个左侧非匹配点

<=> 让左侧非匹配点最少 n-m

<=> 让左侧匹配点最多 m

<=> 找最大匹配边数 m