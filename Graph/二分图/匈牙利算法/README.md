## 匈牙利算法

主要用来解决求二分图的最大匹配数和最小点覆盖问题。前提是图要构成一个二分图

### 最大匹配问题

在二分图中最多能找到多少条没有公共端点的边，最大匹配等价于不存在增广路径。

实现流程(假设图非为两部分，左图和右图)：
    1. 针对左图的每个点，找右侧的连接点，右图的点，在当前匹配中只能找一次。
    2. 如果当前右图的点没有在之前的匹配中被连接过，或者右图的点在左侧的点能够找到新的配对关系，则这对关系依然是成立的

```cpp
bool find(int x){
    for(int i = h[x];i != -1;i = ne[i]){
        int j = e[i];
        if(!st[j]){
            st[j] = true;
            if(match[j] == 0 || find(match[j])){
                match[j] = x;
                return true;
            }
        }
    }
    return false;
}

for(int i = 1;i <= n1;i++){
        //每次开始都是全部没找过的
        //match中是记录着右到左的信息
        memset(st,false,sizeof st);
        if(find(i)) res++;
    }
```

### 最小点覆盖问题

