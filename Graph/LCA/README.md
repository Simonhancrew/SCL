## LCA

两个节点的最近公共祖先，就是这两个点的公共祖先里面，离根最远的那个。假设有点集$ S = \{ s_1,s_2,s_3,....,s_n \} $,其最近公共最先可以表示为LCA(S)

### 一些性质

1. LCA(u) = u

2. 如果u是v的祖先，LCA(u,v) = u

3. 如果u不为v的祖先并且,v不为u的祖先，那么u,v分别处于LCA(u,v)的两棵不同子树中

4. 先序遍历中，LCA出现在集合S中元素之前，后序遍历时，LCA出现在所有的S元素之后

5. LCA(A,B) = LCA(LCA(A),LCA(B))

6. 两点的最近公共祖先必定处在树上两点间的最短路上

7. d(u,v) = h(u) + h(v) - 2h(LCA(u,v))

### 实现方法

1. 向上标记法(O(n))

    从u节点向跟节点遍历，然后标记路径上所有的点。然后从v开始向根节点遍历，第一次遇到标记的点时，就是LCA(u,v)

2. 倍增算法,预处理nlogn + 查询logn

    f[i,j]表示从i开始，向上$ 2^j $步能走到的节点。其中$ j \in [0,log_2(n)]$.depth[i]表示深度/层数
    
    首先需要做的是，把两个点跳到同一层=>把x跳到和y同一层
    
    x,y从同一高度同时起跳后,在f[x][0]!=f[y][0] 的约束下我们能跳的最多的步数跳完后x,y就达到了LCA的下面一层(因为每次都是跳的步数都是2^k的，前面可能还有能继续跳的，不能直接结束)
    
    因为跳的时候f[x][k],f[y][k]的k是从大到小枚举的，所以方便判断最近公共祖先的时候直接跳到不等的地方，然后往上走一步就是结果。
    ```
    int lca(int a, int b)
    {
        if (depth[a] < depth[b])
            swap(a, b);
        for (int i = log(n); i >= 0; i--)
        {
            if (depth[fa[a][i]] >= depth[b])
            {
                a = fa[a][i];
            }
        }
        if (a == b)
            return a;
        for (int i = log(n); i >= 0; i--)
        {
            if (fa[a][i] != fa[b][i]) // 跳的步数是从大到小的,要跳到不能跳为止
            {
                a = fa[a][i];
                b = fa[b][i];
            }
        }
        return fa[a][0];
    }
    ```