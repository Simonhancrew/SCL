# 记忆化搜索

思考的方法等价在做一个dfs，但是从顶开始思考，问题能被缩小成去掉根的子问题

其中，假设函数是`dfs(int)`, 可能会多次进入到一个`dfs(x)`的状态，导致很多重复计算，一般会用一个缓存数组来存储已经计算过的结果，这样可以减少重复计算

```go
f := make([]int, n + 1)
if f[x] != -1 {
  return f[x]
}
```

当然如果内存有限制，且不会线性的走到所有的状态的话，也可以用`unordered_map<int, int>`来做记忆数组
