## 并查集

并查集是一种很容易处理不交集的合并和查询问题的数据结构

并查集中最重要的操作就是查找其祖先节点，比较基础的操作时一层层的往上找，知道找到祖先

```
int p[N]; 
int find(int x) {
  if (p[x] == x) 
    return x;
  else
    return find(p[x]);  
}
```

但是，实质上祖先和父亲节点的关系不大，可以做一个路径压缩，把路径上的每个节点都连接到跟上

```
int find(int x) {
    if(p[x] != x) p[x] = find(p[x]);
    return p[x];
}
```

另外还可能出现的就是带权并查集的题目，需要在合并中看他到根的距离是多少.此类可以递归的做，`d[x]`是当前节点到当前根节点的距离，在换根的时候需要估计新树的size，然后将原集合的根接在新树的根上作为其边权。

```
int find(int x) {
  if(p[x] != x) {
    int root = find(p[x]);
    d[x] += d[p[x]];
    p[x] = root;
  }
  return p[x];
}
```

合并的操作就比较简单, 但值得注意的是要把树根挂到另外一棵树上，直接用`fa[x]`而不用`fa[find(x)]`可能只是让一个子树挂到另外一个树上

```
int pa = find(a),pb = find(b);
p[pa] = pb;
```
另外在合并上还可以考虑启发式的合并（按秩合并）

将一棵点数与深度都较小的集合树连接到一棵更大的集合树下，显然相比于另一种连接方案，接下来执行查找操作的用时更小（也会带来更优的最坏时间复杂度）。

一般点数和深度选择一个作为估价函数就可以了，实际上不用这个优化也比较难TLE

关于复杂度，经过了上述两个优化之后其复杂度是一个阿克曼函数，单次操作的平均时间可以认为是一个很小的常数了
